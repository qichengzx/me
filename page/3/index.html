
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>

  启程
  

</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<link href="/css/style.css" rel="stylesheet" type="text/css">
<meta property="og:type" content="website">
<meta property="og:title" content="启程">
<meta property="og:url" content="https://www.qichengzx.com">
<meta property="og:site_name" content="启程">
<meta property="og:description" content="记录写代码过程中的成长，不要把你仅知道的那一点点东西当成全世界">
<link rel="icon" href="/favicon.ico">

</head>
<body>
<div id="container">
  <div id="wrap">
    
        <header id="header">
          <div id="banner"></div>
          <div id="header-outer" class="outer">
            <div id="header-title" class="inner">
              <h1 id="logo-wrap">
                <a href="https://www.qichengzx.com" id="logo">启程</a>
              </h1>
              
            </div>
            <div id="header-inner" class="inner">
              <nav id="main-nav">
                <a id="main-nav-toggle" class="nav-icon"></a>
                
                <a class="main-nav-link" href="/">Home</a>
                
                <a class="main-nav-link" href="/archives">Archives</a>
                
                <a class="main-nav-link" href="https://github.com">GitHub</a>
                
              </nav>
              <nav id="sub-nav">
              
                <a id="nav-search-btn" class="nav-icon" title="Search"></a>
              </nav>
              <div id="search-form-wrap">
                <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form">
                  <input type="search" name="q" class="search-form-input" placeholder="Search">
                  <button type="submit" class="search-form-submit">&#xF002;</button>
                  <input type="hidden" name="sitesearch" value="https://www.qichengzx.com">
                </form>
              </div>
            </div>
          </div>
        </header>

    <div class="outer">
      <section id="main">
      
        
        
                <article id="a73f5e067d643a87e5d36f7ae3799355" class="article" itemscope itemprop="blogPost">
                  <div class="article-meta">
                    <a href="https://www.qichengzx.com/2017/07/02/HTTP2-Server-Push.html" class="article-date">
                      <time itemprop="datePublished">2017-07-02 00:09:13</time>
                    </a>
                    <div class="article-category">
                      <a class="article-category-link" href="/categories/golang">golang</a>
                    </div>
                  </div>
                  <div class="article-inner">
                    <header class="article-header">
                      <h1 itemprop="name">
                        <a class="article-title" href="https://www.qichengzx.com/2017/07/02/HTTP2-Server-Push.html">在Go中使用 HTTP/2 Server Push</a>
                      </h1>
                    </header>
                    <div class="article-entry" itemprop="articleBody">
                      <h4>写在前面</h4>

<p>本文来自<a href="https://blog.golang.org/h2push">Golang的官方博客</a>，由 Jaana Burcu Dogan, Tom Bergan 发表于2017年3月24日。</p>

<p>近来看到此篇，觉得不错，非常适合用来学习Go中的 Server Push ，于是决定翻译一下，水平有限，如有不足不恰当的地方还请提出宝贵意见。</p>

<h4>序</h4>

<p>HTTP/2旨在解决HTTP/1.x的很多问题。现代网页通常包含很多资源：HTML，css，js，图片等等。在 HTTP/1.x 中，必须明确地请求这些资源。这是一个缓慢的过程。浏览器必须从获取HTML开始，然后在解析页面时获取更多资源。由于服务器必须等待浏览器发起请求，网络通常处于空闲，没有充分利用。</p>

<p>为了改善延迟，HTTP/2引入了 Server Push ，这允许服务器在明确的请求之前将资源推送到浏览器。服务器通常会知道一个页面所需要的额外的资源，并且可以在响应初始请求时开始推送这些资源。这就允许服务器充分利用空闲的网络来改善加载时间。</p>

<p><img src="/images/go/serverpush.svg" alt="server push示意" /></p>

<p>在协议层，HTTP/2 Server Push 由 PUSH_PROMISE 帧发起。PUSH_PROMISE 表明了服务器向客户端推送资源的意图。一旦浏览器接收到PUSH_PROMISE，它就会知道服务器会推送资源。如果浏览器后来发现需要这个资源，它会等待推送完成，而不是发起一个新的请求。这减少了浏览器在网络上等待的时间。</p>

<h4>net/http 包中的 Server Push</h4>

<p>Go1.8 引入了 http.Server 对 push 响应的支持，如果运行的服务器是 HTTP/2 服务器，并且请求连接使用了 HTTP/2，则可以使用此功能。在任何HTTP处理程序中，可以通过检查 http.ResponseWriter 是否实现了 http.Pusher 接口来判断是否支持 Server Push。</p>

<p>例如，如果服务器知道一个页面中包含 app.js，处理程序可以初始化一个 http.Pusher。</p>

<pre><code class="language-go">http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) {
  if push, ok := w.(http.Pusher); ok {
    //支持Push
    if err := pusher.Push(&quot;/app.js&quot;, nil); err != nil {
      log.Printf(&quot;Failed to push: %v&quot;, err)
    }
  }
  // ...
})
</code></pre>

<p>Push会为 app.js 创建一个 “合成请求”，将该请求合成到 PUSH_PROMISE 帧中，然后将请求转发到服务器的请求处理程序，请求处理程序会生成响应。Push的第二个参数指定了包含在 PUSH_PROMISE 中的附加header头，例如，如果对 app.js 的响应在 Accept-Encoding 上不同，则 PUSH_PROMISE 应包含 Accept-Encoding 的值。</p>

<pre><code class="language-go">http.HandleFunc(&quot;/&quot;, func(w http.ResponseWriter, r *http.Request) {
  if pusher, ok := w.(http.Pusher); ok {
    //支持Push
    options := &amp;http.PushOptions{
      Header: http.Header{
        &quot;Accept-Encoding&quot;: r.Header[&quot;Accept-Encoding&quot;],
      },
    }
    if err := pusher.Pusher(&quot;/app.js&quot;, options); err != nil {
      log.Printf(&quot;Failed to push: %v&quot;, err)
    }
  }
  // ...
})
</code></pre>

<p>完整示例见：</p>

<pre><code class="language-shell">$ go get golang.org/x/blog/content/h2push/server
</code></pre>

<p>启动服务，然后打开 <a href="https://localhost:8080">https://localhost:8080</a>，浏览器开发工具应该会显示服务器推送了 app.js 和 style.css 。</p>

<p><img src="/images/go/networktimeline.png" alt="网络请求耗时" /></p>

<h4>在响应前开始Push</h4>

<p>在发送响应之前调用Push是个好主意，否则可能会意外产生重复的响应，例如，假设下边是HTML响应的一部分：</p>

<pre><code class="language-html">&lt;html&gt;
&lt;head&gt;
	&lt;link rel=&quot;stylesheet&quot; href=&quot;a.cs&quot;&gt;...	
</code></pre>

<p>然后调用 Push(&ldquo;a.css&rdquo;, nil) ，浏览器可能会在接收到 PUSH_PROMISE 之前就开始解析这段 HTM L了，这种情况下，浏览器除了接收到 PUSH_PROMISE 之外，还会发起一个 a.css 的请求，那么服务器就会为 a.css 生成两个请求。而在写入响应之前调用PUSH则避免了这种可能性。</p>

<h4>何时使用Server Push</h4>

<p>应该考虑在任何网络连接空闲时使用 Server Push 。刚完成为 web app 发送 HTML ？不要浪费时间等待请求，开始推送客户端需要用到的资源，你有没有过将资源嵌入到 HTML 文件中以减少延迟？替换掉内联，尝试使用推送。重定向是另一个使用推送的好时机，因为客户端在这个过程中几乎把时间全浪费在请求的往返上。有很多情况适合使用 Push ，我们才刚刚开始。</p>

<p>如果没有提到以下几个注意事项，将是我们的失职。</p>

<p>​   首先，只能推送当前服务器上的资源-这意味着无法推送托管在第三方服务器或CDN上的资源。</p>

<p>​   第二，除非能确定客户端确实需要，否则不要推送，这样会浪费带宽。当浏览器已经缓存了某些资源时， 必须要避免推送。</p>

<p>​   第三，天真的把所有资源推送到页面会使性能更糟糕。</p>

<p>以下链接可以作为补充阅读：</p>

<ul>
<li><a href="https://calendar.perfplanet.com/2016/http2-push-the-details/">HTTP/2 Push: The Details</a></li>
<li><a href="https://www.igvita.com/2013/06/12/innovating-with-http-2.0-server-push/">Innovating with HTTP/2 Server Push</a></li>
<li><a href="https://github.com/h2o/h2o/issues/421">Cache-Aware Server Push in H2O</a></li>
<li><a href="https://developers.google.com/web/fundamentals/performance/prpl-pattern/">The PRPL Pattern</a></li>
<li><a href="https://docs.google.com/document/d/1K0NykTXBbbbTlv60t5MyJvXjqKGsCVNYHyLEXIxYMv0">Rules of Thumb for HTTP/2 Push</a></li>
<li><a href="https://tools.ietf.org/html/rfc7540#section-8.2">Server Push in the HTTP/2 spec</a></li>
</ul>

<h4>结尾</h4>

<p>Go1.8 标准库为 HTTP/2 Server Push 提供了开箱即用的支持，为优化 Web 应用程序提供更多灵活性。</p>

<p>转到<a href="https://http2.golang.org/serverpush">HTTP/2 Server Push演示页面</a>查看实际效果。</p>

<h4>一些资料</h4>

<p><a href="https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-cn">HTTP/2 简介</a></p>

<p>HTTP/2 Server Push 详解：</p>

<p>原文：</p>

<p><a href="https://www.smashingmagazine.com/2017/04/guide-http2-server-push/">A Comprehensive Guide To HTTP/2 Server Push</a></p>

<p>译文：</p>

<p><a href="http://www.alloyteam.com/2017/04/guide-http2-server-push-part1/">HTTP/2 Server Push 详解（上）</a></p>

<p><a href="http://www.alloyteam.com/2017/04/guide-http2-server-push-part2/">HTTP/2 Server Push 详解（下）</a></p>

                    </div>
                    <footer class="article-footer">
                      <a href="https://www.qichengzx.com/2017/07/02/HTTP2-Server-Push.html#comments" class="article-comment-link">Comments</a>
                      
                        <ul class="article-tag-list">
                        
                          <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/go">go</a>
                          </li>
                        
                        </ul>
                      
                    </footer>
                  </div>
                  <nav id="article-nav">
                    

                    
                  </nav>
                </article>

        
        
                <article id="543d34e1e7ac1a0d309eb2356850f2e1" class="article" itemscope itemprop="blogPost">
                  <div class="article-meta">
                    <a href="https://www.qichengzx.com/2017/06/27/order-by-distance-in-mysql.html" class="article-date">
                      <time itemprop="datePublished">2017-06-27 22:18:19</time>
                    </a>
                    <div class="article-category">
                      <a class="article-category-link" href="/categories/mysql">mysql</a>
                    </div>
                  </div>
                  <div class="article-inner">
                    <header class="article-header">
                      <h1 itemprop="name">
                        <a class="article-title" href="https://www.qichengzx.com/2017/06/27/order-by-distance-in-mysql.html">MySQL实现按经纬度做距离排序</a>
                      </h1>
                    </header>
                    <div class="article-entry" itemprop="articleBody">
                      <p><img src="/images/geolocation.png" alt="" />
题图来自网络</p>

<p>工作中某些业务需要用到按距离排序返回结果，之前的方式是根据前端传过来来的经纬度，和指定范围的距离，算出一个坐标区间，再用这个区间的值去MySQL中查找，类似“where lat between (lat1, lat2) and lng between (lng1,lng2)”，查出数据后，再遍历数据计算每一条数据到这个经纬度的距离，然后根据得出的距离排序返回。低效，麻烦，不方便分页。</p>

<p>于是决定直接从MySQL中算出距离后返回，省事，方便，还可以直接分页了。</p>

<p>查资料后发现还挺简单的，下方的示例是从<a href="https://developers.google.com/maps/articles/phpsqlsearch_v3">Google官方的文档</a>中摘取出来。</p>

<p>创建如下数据表：</p>

<pre><code class="language-mysql">CREATE TABLE `markers` (
  `id` INT NOT NULL AUTO_INCREMENT PRIMARY KEY ,
  `name` VARCHAR( 60 ) NOT NULL ,
  `address` VARCHAR( 80 ) NOT NULL ,
  `lat` FLOAT( 10, 6 ) NOT NULL ,
  `lng` FLOAT( 10, 6 ) NOT NULL
) ENGINE = MYISAM ;
</code></pre>

<p>填充数据：</p>

<pre><code class="language-mysql">INSERT INTO `markers` (`name`, `address`, `lat`, `lng`) VALUES ('Frankie Johnnie &amp; Luigo Too','939 W El Camino Real, Mountain View, CA','37.386339','-122.085823');
INSERT INTO `markers` (`name`, `address`, `lat`, `lng`) VALUES ('Amici\'s East Coast Pizzeria','790 Castro St, Mountain View, CA','37.38714','-122.083235');
INSERT INTO `markers` (`name`, `address`, `lat`, `lng`) VALUES ('Kapp\'s Pizza Bar &amp; Grill','191 Castro St, Mountain View, CA','37.393885','-122.078916');
INSERT INTO `markers` (`name`, `address`, `lat`, `lng`) VALUES ('Round Table Pizza: Mountain View','570 N Shoreline Blvd, Mountain View, CA','37.402653','-122.079354');
INSERT INTO `markers` (`name`, `address`, `lat`, `lng`) VALUES ('Tony &amp; Alba\'s Pizza &amp; Pasta','619 Escuela Ave, Mountain View, CA','37.394011','-122.095528');
INSERT INTO `markers` (`name`, `address`, `lat`, `lng`) VALUES ('Oregano\'s Wood-Fired Pizza','4546 El Camino Real, Los Altos, CA','37.401724','-122.114646');
</code></pre>

<p>下面，开始从表中查询数据。</p>

<p>根据latitude，longitude值，基于<a href="http://en.wikipedia.org/wiki/Haversine_formula">Haversine公式</a>从表中查询数据。</p>

<p>假设我们要查询latitude=37.38714,longitude=-122.083235，范围在25英里内的前20条数据，可以这样：</p>

<pre><code class="language-mysql">SELECT id, ( 3959 * acos( cos( radians('37.38714') ) * cos( radians( lat ) ) * cos( radians( lng ) - radians('-122.083235') ) + sin( radians('37.38714') ) * sin( radians( lat ) ) ) ) AS distance FROM markers HAVING distance &lt; 25 ORDER BY distance LIMIT 0, 20;
</code></pre>

<p>如果想使用“公里”代替“英里”，将3959换成6371即可。</p>

<p>特别简单。</p>

<p>参考资料：</p>

<p><a href="https://developers.google.com/maps/articles/phpsqlsearch_v3">Creating a Store Locator with PHP, MySQL &amp; Google Maps</a></p>

<p><a href="https://zh.scribd.com/presentation/2569355/Geo-Distance-Search-with-MySQL">Geo/Spatial Search with MySQL</a></p>

                    </div>
                    <footer class="article-footer">
                      <a href="https://www.qichengzx.com/2017/06/27/order-by-distance-in-mysql.html#comments" class="article-comment-link">Comments</a>
                      
                        <ul class="article-tag-list">
                        
                          <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/mysql">mysql</a>
                          </li>
                        
                        </ul>
                      
                    </footer>
                  </div>
                  <nav id="article-nav">
                    

                    
                  </nav>
                </article>

        
        
                <article id="740de747745d69cb2c6d653b81f1ce05" class="article" itemscope itemprop="blogPost">
                  <div class="article-meta">
                    <a href="https://www.qichengzx.com/2017/03/06/insert-filter-in-beego.html" class="article-date">
                      <time itemprop="datePublished">2017-03-06 08:23:47</time>
                    </a>
                    <div class="article-category">
                      <a class="article-category-link" href="/categories/golang">golang</a>
                    </div>
                  </div>
                  <div class="article-inner">
                    <header class="article-header">
                      <h1 itemprop="name">
                        <a class="article-title" href="https://www.qichengzx.com/2017/03/06/insert-filter-in-beego.html">Beego中使用过滤器</a>
                      </h1>
                    </header>
                    <div class="article-entry" itemprop="articleBody">
                      <p>为了方便调试和排错，决定在现有的beego程序里加上requestID。</p>

<p>查了些资料发现写的并不是特别清楚和详细，在此总结一下，也算是加深下印象。</p>

<p>astaxie说可以用过滤器实现，就是在Beego运行时在特定的步骤前加入。而由于我的需求比较简单，就选在了BeforeRouter。</p>

<p>在main.go中:</p>

<pre><code class="language-Go">import &quot;github.com/astaxie/beego/context&quot;
import &quot;github.com/satori/go.uuid&quot;

</code></pre>

<p>在main函数中加入:</p>

<pre><code class="language-Go">var FilterRequestID = func(ctx *context.Context) {
	requestId := uuid.NewV4().String()
	ctx.Input.SetData(&quot;requestId&quot;, requestId)
}

beego.InsertFilter(&quot;/*&quot;, beego.BeforeRouter, FilterRequestID)

</code></pre>

<p>在需要使用的地方，如</p>

<pre><code class="language-Go">// @router /requestid [get]
func (this *MyController) Requestid() {
	//读取requestId
	rid := this.Ctx.Input.GetData(&quot;requestId&quot;).(string)

	fmt.Println(&quot;requestId:&quot;,rid)
}
</code></pre>

<p>或者</p>

<pre><code class="language-Go">func (m *MyController) Requestid() {
	rid := m.Ctx.Input.GetData(&quot;requestId&quot;).(string)

	fmt.Println(&quot;requestId:&quot;,rid)
}
</code></pre>

<p>其实很简单，但是文档和查到的资料中都没有明确的说需要引用 &ldquo;github.com/astaxie/beego/context&rdquo;，导致写的时候浪费了一些时间。</p>

<p>参考资料:</p>

<p><a href="https://beego.me/docs/mvc/controller/filter.md">过滤器</a>
<a href="https://gocn.io/article/95">beego log中增加request id的一种方式</a></p>

                    </div>
                    <footer class="article-footer">
                      <a href="https://www.qichengzx.com/2017/03/06/insert-filter-in-beego.html#comments" class="article-comment-link">Comments</a>
                      
                        <ul class="article-tag-list">
                        
                          <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/go">go</a>
                          </li>
                        
                        </ul>
                      
                    </footer>
                  </div>
                  <nav id="article-nav">
                    

                    
                  </nav>
                </article>

        
        
                <article id="5ec75bc5e5f69005cf2ff1c8c4141d18" class="article" itemscope itemprop="blogPost">
                  <div class="article-meta">
                    <a href="https://www.qichengzx.com/2016/12/27/shortlen-url-by-go.html" class="article-date">
                      <time itemprop="datePublished">2016-12-27 21:27:34</time>
                    </a>
                    <div class="article-category">
                      <a class="article-category-link" href="/categories/golang">golang</a>
                    </div>
                  </div>
                  <div class="article-inner">
                    <header class="article-header">
                      <h1 itemprop="name">
                        <a class="article-title" href="https://www.qichengzx.com/2016/12/27/shortlen-url-by-go.html">Go语言写的一个短网址服务</a>
                      </h1>
                    </header>
                    <div class="article-entry" itemprop="articleBody">
                      <p><img src="/images/go/best-url-shortener-to-make-earn-money.png" alt="" />
<center>题图来自<a href="http://www.dwtricks.com/2015/05/best-10-url-shortener-networks-to-earn-money-2015.html/">http://www.dwtricks.com/</a></center></p>

<p>&ldquo;缩址，又称短址、短网址、网址缩短、缩短网址、URL缩短等，指的是一种互联网上的技术与服务。此服务可以提供一个非常短小的URL以代替原来的可能较长的URL，将长的URL地址缩短。
用户访问缩短后的URL时，通常将会重定向到原来的URL。&rdquo;</p>

<p>&ndash; Wikipedia</p>

<p>虽然短网址早已不再那么受广泛关注。但是不妨拿来练手。</p>

<p>根据公开可以搜索到的资料，短网址一般是将一个ID转换到一串字母，生成短的网址用于传播，实际访问会重定向到原网址。如上所述。</p>

<p>那么使用Go来写这个有什么优势呢，优势之一当然是，Go部署简单，只需要copy执行文件即可。执行速度也快，甚至连HTTP服务器都不需要。</p>

<h5>下边就边写边说明。</h5>

<pre><code class="language-go">package main

import (
	&quot;fmt&quot;
	&quot;strings&quot;
	&quot;time&quot;
	&quot;net/http&quot;
	&quot;database/sql&quot;

	&quot;github.com/gin-gonic/gin&quot;

	&quot;github.com/garyburd/redigo/redis&quot;
	_ &quot;github.com/go-sql-driver/mysql&quot;

	&quot;github.com/speps/go-hashids&quot;
)
</code></pre>

<h6>定义hashid包需要的salt，即生成字符串的最短位数。</h6>

<pre><code class="language-go">const (
	hdSalt        = &quot;mysalt&quot;
	hdMinLength   = 5
	defaultDomain = &quot;http://localhost:8000/&quot;
)
</code></pre>

<h6>定义redis和MySQL的配置信息</h6>

<pre><code class="language-go">var (
	RedisClient *redis.Pool
	RedisHost   = &quot;127.0.0.1:6379&quot;
	RedisDb     = 0
	RedisPwd    = &quot;&quot;

	db      *sql.DB
	DB_HOST = &quot;tcp(127.0.0.1:3306)&quot;
	DB_NAME = &quot;short&quot;
	DB_USER = &quot;root&quot;
	DB_PASS = &quot;&quot;
)
</code></pre>

<h5>main函数，首先连接redis和MySQL。定义如下路由：</h5>

<ul>
<li>访问首页</li>
<li>访问hash</li>
<li>访问短网址信息页</li>
<li>生成短网址接口</li>
</ul>

<p>熟悉的朋友应该都知道，访问短网址服务的首页一般会跳转到一个固定的网址，比如渣浪微博会跳转到微博首页，Twitter则是给出“Twitter uses the t.co domain as part of a service to protect users from harmful activity”的提示。这里我们也让它跳转到一个指定的网页。</p>

<p>最后，以8080端口运行，实际线上会使用80端口，可以自行修改。</p>

<pre><code class="language-go">func main() {
	initRedis()
	initMysql()

	gin.SetMode(gin.DebugMode)
	r := gin.Default()

	r.GET(&quot;/&quot;, func(c *gin.Context) {
		//http code can be StatusFound or StatusMovedPermanently 
		c.Redirect(http.StatusFound, defaultDomain)
	})
	r.GET(&quot;/:hash&quot;, expandUrl)
	r.GET(&quot;/:hash/info&quot;, expandUrlApi)
	r.POST(&quot;/short&quot;, shortUrl)

	r.Run(&quot;:8000&quot;)
}
</code></pre>

<h5>连接redis和MySQL</h5>

<pre><code class="language-go">func initRedis() {
	// 建立连接池
	RedisClient = &amp;redis.Pool{
		MaxIdle:     1,
		MaxActive:   10,
		IdleTimeout: 180 * time.Second,
		Dial: func() (redis.Conn, error) {
			c, err := redis.Dial(&quot;tcp&quot;, RedisHost)
			if err != nil {
				return nil, err
			}
			if _, err := c.Do(&quot;AUTH&quot;, RedisPwd); err != nil {
				c.Close()
				return nil, err
			}
			c.Do(&quot;SELECT&quot;, RedisDb)
			return c, nil
		},
	}
}

func initMysql() {
	dsn := DB_USER + &quot;:&quot; + DB_PASS + &quot;@&quot; + DB_HOST + &quot;/&quot; + DB_NAME + &quot;?charset=utf8&quot;
	db, _ = sql.Open(&quot;mysql&quot;, dsn)
	db.SetMaxOpenConns(5)
	db.SetMaxIdleConns(20)
	db.Ping()
}
</code></pre>

<h5>生成短网址的接口函数。</h5>

<p>根据传入的URL参数，进行简单的验证后，写入数据库。根据写入后生成的ID，再生成一个字符串，然后返回给调用方。</p>

<pre><code class="language-go">func shortUrl(c *gin.Context) {
	longUrl := c.PostForm(&quot;url&quot;)

	if longUrl == &quot;&quot; {
		c.JSON(200, gin.H{
			&quot;status&quot;:  500,
			&quot;message&quot;: &quot;请传入网址&quot;,
		})
		return
	}

	if !strings.HasPrefix(longUrl, &quot;http&quot;) {
		longUrl = &quot;http://&quot; + longUrl
	}

	if hash, ok := insert(longUrl); ok {
		c.JSON(200, gin.H{
			&quot;status&quot;:  200,
			&quot;message&quot;: &quot;ok&quot;,
			&quot;short&quot;:   defaultDomain + hash,
		})
	}
}
</code></pre>

<h5>根据HASH解析并跳转到对应的长URL，不存在则跳转到默认地址</h5>

<pre><code class="language-go">func expandUrl(c *gin.Context) {
	hash := c.Param(&quot;hash&quot;)

	if url, ok := findByHash(hash); ok {
		c.Redirect(http.StatusMovedPermanently, url)
	}
	// 注意:
	// 	实际中，此应用的运行域名可能与默认域名不同，如a.com运行此程序，默认域名为b.com
	// 	当访问一个不存在的HASH或a.com时，可以跳转到任意域名，即defaultDomain
	c.Redirect(http.StatusMovedPermanently, defaultDomain)
}
</code></pre>

<h5>根据HASH在redis中查找并返回结果，不存在则返回404状态</h5>

<pre><code class="language-go">func expandUrlApi(c *gin.Context) {
	hash := c.Param(&quot;hash&quot;)

	if url, ok := findByHash(hash); ok {
		c.JSON(200, gin.H{
			&quot;status&quot;:  200,
			&quot;message&quot;: &quot;ok&quot;,
			&quot;data&quot;:    url,
		})
		return
	}

	// 此处可以尝试在MySQL中再次查询
	c.JSON(200, gin.H{
		&quot;status&quot;:  404,
		&quot;message&quot;: &quot;url of hash is not exist&quot;,
	})
}
</code></pre>

<h5>将ID转换成对应的HASH值，hdSalt与hdMinLength 会影响生成结果，确定后不要改动</h5>

<pre><code class="language-go">func shortenURL(id int) string {
	hd := hashids.NewData()
	hd.Salt = hdSalt
	hd.MinLength = hdMinLength

	h := hashids.NewWithData(hd)
	e, _ := h.Encode([]int{id})

	return e
}
</code></pre>

<h5>根据HASH解析出对应的ID值, hdSalt与hdMinLength 会影响生成结果，确定后不要改动</h5>

<pre><code class="language-go">func expand(hash string) int {
	hd := hashids.NewData()
	hd.Salt = hdSalt
	hd.MinLength = hdMinLength

	h := hashids.NewWithData(hd)
	d, _ := h.DecodeWithError(hash)

	return d[0]
}
</code></pre>

<h5>数据库中根据ID查找</h5>

<pre><code class="language-go">func find(id int) (string, bool) {
	var url string
	err := db.QueryRow(&quot;SELECT url FROM url WHERE id = ?&quot;, id).Scan(&amp;url)
	if err == nil {
		return url, true
	} else {
		return &quot;&quot;, false
	}
}
</code></pre>

<h5>在redis中根据HASH查找</h5>

<pre><code class="language-go">func findByHash(h string) (string, bool) {
	rc := RedisClient.Get()

	defer rc.Close()
	url, _ := redis.String(rc.Do(&quot;GET&quot;, &quot;URL:&quot;+h))

	if url != &quot;&quot; {
		return url, true
	}

	id := expand(h)
	if urldb, ok := find(id); ok {
		return urldb, true
	}

	return &quot;&quot;, false
}
</code></pre>

<h5>将长网址插入到数据库中，并把返回的ID生成HASH和长网址存入redis</h5>

<pre><code class="language-go">func insert(url string) (string, bool) {
	stmt, _ := db.Prepare(`INSERT INTO url (url) values (?)`)
	res, err := stmt.Exec(url)
	checkErr(err)

	id, _ := res.LastInsertId()

	rc := RedisClient.Get()
	defer rc.Close()

	hash := shortenURL(int(id))
	rc.Do(&quot;SET&quot;, &quot;URL:&quot;+hash, url)

	return hash, true
}
</code></pre>

<h4>打印方法，和检查错误的方法</h4>

<pre><code class="language-go">func Log(v ...interface{}) {
	fmt.Println(v...)
}

func checkErr(err error) {
	if err != nil {
		panic(err)
	}
}
</code></pre>

<p>有些地方还需修改，就算是抛砖引玉吧。</p>

<p>感谢<a href="http://hashids.org/">hashids</a></p>

<h4>Github地址 ： <a href="https://github.com/qichengzx/shortme">shortme</a></h4>

<p>相关资料：</p>

<p><a href="http://mashable.com/2008/01/08/url-shortening-services/#CgEzOrfnzPqb">URL Toolbox: 90+ URL Shortening Services</a>
<a href="http://tinyurl.com/">TinyURL</a></p>

                    </div>
                    <footer class="article-footer">
                      <a href="https://www.qichengzx.com/2016/12/27/shortlen-url-by-go.html#comments" class="article-comment-link">Comments</a>
                      
                        <ul class="article-tag-list">
                        
                          <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/go">go</a>
                          </li>
                        
                          <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/%e7%9f%ad%e7%bd%91%e5%9d%80">短网址</a>
                          </li>
                        
                        </ul>
                      
                    </footer>
                  </div>
                  <nav id="article-nav">
                    

                    
                  </nav>
                </article>

        
        
                <article id="a613e354bbefc581f5bedca0a0968c2d" class="article" itemscope itemprop="blogPost">
                  <div class="article-meta">
                    <a href="https://www.qichengzx.com/2016/12/14/toutiao-images-spider-by-golang.html" class="article-date">
                      <time itemprop="datePublished">2016-12-14 16:28:36</time>
                    </a>
                    <div class="article-category">
                      <a class="article-category-link" href="/categories/golang">golang</a>
                    </div>
                  </div>
                  <div class="article-inner">
                    <header class="article-header">
                      <h1 itemprop="name">
                        <a class="article-title" href="https://www.qichengzx.com/2016/12/14/toutiao-images-spider-by-golang.html">Go 福利小爬虫 爬取今日头条美女图</a>
                      </h1>
                    </header>
                    <div class="article-entry" itemprop="articleBody">
                      <p><img src="/images/go/toutiao.gif" alt="" /></p>

<p>写完爬取糗百热门后没几天，又开始写了爬取今日头条图片的<a href="https://github.com/qichengzx/toutiaoSpider">工具</a>。</p>

<p>灵感来源于<a href="http://www.jianshu.com/p/d67b1d4b99ad">Python 福利小爬虫，爬取今日头条街拍美女图</a>，作者很详细的分析了今日头条一个搜索接口，并列出了步骤。</p>

<p>而我用Go写的，稍稍做了改动，加入了可以自定义爬取标签的功能，并在写本文前完成了以 &ldquo;标签/文章名/图片名&rdquo; 结构存储图片的功能。</p>

<p>分析网页依然使用<a href="https://github.com/PuerkitoBio/goquery">goquery</a>。</p>

<h3>分析接口返回结构</h3>

<pre><code class="language-json">{
	&quot;count&quot;: 30,
	&quot;action_label&quot;: &quot;click_search&quot;,
	&quot;return_count&quot;: 0,
	&quot;has_more&quot;: 0,
	&quot;page_id&quot;: &quot;/search/&quot;,
	&quot;cur_tab&quot;: 1,
	&quot;offset&quot;: 150,
	&quot;action_label_web&quot;: &quot;click_search&quot;,
	&quot;show_tabs&quot;: 1,
	&quot;data&quot;: [
		{
			&quot;play_effective_count&quot;: &quot;6412&quot;,
			&quot;media_name&quot;: &quot;开物志&quot;,
			&quot;repin_count&quot;: 49,
			&quot;ban_comment&quot;: 0,
			&quot;show_play_effective_count&quot;: 1,
			&quot;abstract&quot;: &quot;&quot;,
			&quot;display_title&quot;: &quot;&quot;,
			&quot;datetime&quot;: &quot;2016-12-13 21:35&quot;,
			&quot;article_type&quot;: 0,
			&quot;more_mode&quot;: false,
			&quot;create_time&quot;: 1481636117,
			&quot;has_m3u8_video&quot;: 0,
			&quot;keywords&quot;: &quot;&quot;,
			&quot;video_duration&quot;: 161,
			&quot;has_mp4_video&quot;: 0,
			&quot;favorite_count&quot;: 49,
			&quot;aggr_type&quot;: 0,
			&quot;article_sub_type&quot;: 0,
			&quot;bury_count&quot;: 2,
			&quot;title&quot;: &quot;沃尔沃Tier 4 Final大型引擎的工作原理揭秘&quot;,
			&quot;has_video&quot;: true,
			&quot;share_url&quot;: &quot;http://toutiao.com/group/6363577276176531969/?iid=0&amp;app=news_article&quot;,
			&quot;id&quot;: 6363577276176532000,
			&quot;source&quot;: &quot;开物志&quot;,
			&quot;comment_count&quot;: 4,
			&quot;article_url&quot;: &quot;http://toutiao.com/group/6363577276176531969/&quot;,
			&quot;image_url&quot;: &quot;http://p3.pstatp.com/list/12f0000909de79ceeabc&quot;,
			&quot;middle_mode&quot;: true,
			&quot;large_mode&quot;: false,
			&quot;item_source_url&quot;: &quot;/group/6363577276176531969/&quot;,
			&quot;media_url&quot;: &quot;http://toutiao.com/m6643043415/&quot;,
			&quot;display_time&quot;: 1481635793,
			&quot;publish_time&quot;: 1481635793,
			&quot;go_detail_count&quot;: 2290,
			&quot;image_list&quot;: [],
			&quot;item_seo_url&quot;: &quot;/group/6363577276176531969/&quot;,
			&quot;video_duration_str&quot;: &quot;02:41&quot;,
			&quot;source_url&quot;: &quot;/group/6363577276176531969/&quot;,
			&quot;tag_id&quot;: 6363577276176532000,
			&quot;natant_level&quot;: 0,
			&quot;seo_url&quot;: &quot;/group/6363577276176531969/&quot;,
			&quot;display_url&quot;: &quot;http://toutiao.com/group/6363577276176531969/&quot;,
			&quot;url&quot;: &quot;http://toutiao.com/group/6363577276176531969/&quot;,
			&quot;level&quot;: 0,
			&quot;digg_count&quot;: 4,
			&quot;behot_time&quot;: 1481635793,
			&quot;tag&quot;: &quot;news_car&quot;,
			&quot;has_gallery&quot;: false,
			&quot;has_image&quot;: false,
			&quot;highlight&quot;: {
			&quot;source&quot;: [],
			&quot;abstract&quot;: [],
			&quot;title&quot;: []
			},
			&quot;group_id&quot;: 6363577276176532000,
			&quot;middle_image&quot;: &quot;http://p3.pstatp.com/list/12f0000909de79ceeabc&quot;
		},
	],
	&quot;message&quot;: &quot;success&quot;,
	&quot;action_label_pgc&quot;: &quot;click_search&quot;
}
</code></pre>

<p>嗯，特别多，其实只需要 data 里的内容就可以了。</p>

<p>所以</p>

<h4>构造一个请求结果的struct。</h4>

<pre><code class="language-go">type ApiData struct {
	Has_more int    `json:&quot;has_more&quot;`
	Data     []Data `json:&quot;data&quot;`
}
</code></pre>

<p>再看下data里，嗯，没用的又一大堆。</p>

<h4>只需要文章链接就够了。</h4>

<pre><code class="language-go">type Data struct {
	Article_url string `json:&quot;article_url&quot;`
}
</code></pre>

<p>有了文章链接，那就好说了，啥都好商量。</p>

<h4>分析文章结构</h4>

<p>id=&ldquo;J_content&rdquo; 下是文章的主要内容，class=&ldquo;article-title&rdquo;是文章标题，class=&ldquo;article-content&rdquo;里是文章内容，只需要article-content里所有img元素就可以了。</p>

<pre><code class="language-go">type Img struct {
	Src string `json:&quot;src&quot;`
}
</code></pre>

<p>由于需要一直更改查询接口的offset参数，所以直接把接口地址拿到外边做了全局变量。并且默认存在下一页。tag用来表示当前爬取的标签的名称。</p>

<pre><code class="language-go">var (
	host    string = &quot;http://www.toutiao.com/search_content/?format=json&amp;keyword=%s&amp;count=30&amp;offset=%d&quot;
	hasmore bool   = true
	tag     string
)
</code></pre>

<h3>正菜</h3>

<h4>0. 接收参数</h4>

<p>首先，接收并遍历命令行中传入的标签。</p>

<pre><code class="language-go">func main() {
	for _, tag = range os.Args[1:] {
		hasmore = true
		getByTag()
	}
	log.Println(&quot;全部抓取完毕&quot;)
}
</code></pre>

<p>每个循环开始时重置 hasmore 。</p>

<h4>1. 循环请求接口</h4>

<pre><code class="language-go">func getByTag() {
	i, offset := 1, 0
	for {
		if hasmore {
			log.Printf(&quot;标签: '%s'，第 '%d' 页, OFFSET: '%d' \n&quot;, tag, i, offset)
			tmpUrl := fmt.Sprintf(host, tag, offset)
			getResFromApi(tmpUrl)
			offset += 30
			i++

			time.Sleep(500 * time.Millisecond)
		} else {
			break
		}
	}
	log.Printf(&quot;标签: '%s', 共 %v 页，爬取完毕\n&quot;, tag, i-1)
}
</code></pre>

<p>重置当前页，和当前offset。页数从第一页开始，主要是显示进度看起来更人性化一些。但是程序员的世界是从0开始。。。想改成0就改成0吧。</p>

<p>hasmore = true 表示存在下一页，使用fmt包的Sprintf方法格式化请求链接。然后对offset+30，对当前页i+1。再之后停顿了500毫秒。</p>

<p>这里其实有个问题，如果实际内容以每页30请求，可能恰好有150条，即每页数量的整数倍，但是这个时候接口返回的has_more依然等于1，即服务端认为还有下一页。。。但是其实没有了，所以会有一次空循环。</p>

<h4>2. 处理请求结果</h4>

<pre><code class="language-go">func getResFromApi(url string) {
	resp, err := http.Get(url)
	if err != nil {
		log.Fatal(err)
	}

	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body)

	if err != nil {
		log.Fatal(err)
	}

	var res ApiData
	json.Unmarshal([]byte(string(body)), &amp;res)

	for _, item := range res.Data {
		getImgByPage(item.Article_url)
	}

	if res.Has_more == 0 {
		hasmore = false
	}
}
</code></pre>

<p>没啥说的，拿到每一个请求接口的链接后打开，把结果数组中的data解析到ApiData中，于是就拿到了文章链接，然后遍历处理。</p>

<p>遍历完后要看下has_more的值，如果为0表示没有下一页了，修改全局变量hasmore的值，结束最外层的循环。</p>

<h4>3. 处理文章</h4>

<pre><code class="language-go">func getImgByPage(url string) {
	//部分请求结果中包含其他网站的链接，会导致下面的query出现问题
	if strings.Contains(url, &quot;toutiao.com&quot;) {
		doc, err := goquery.NewDocument(url)
		if err != nil {
			log.Fatal(err)
		}

		title := doc.Find(&quot;#article-main .article-title&quot;).Text()
		title = strings.Replace(title, &quot;/&quot;, &quot;&quot;, -1)
		os.MkdirAll(tag+&quot;/&quot;+title, 0777)

		doc.Find(&quot;#J_content .article-content img&quot;).Each(func(i int, s *goquery.Selection) {
			src, _ := s.Attr(&quot;src&quot;)
			log.Println(title, src)
			getImgAndSave(src, title)
		})
	}
}

</code></pre>

<p>最外层加了判断，是因为有一部分结果的链接是其他网站的。。。。</p>

<p>虽然这个判断很low，但是也够用了。</p>

<p>然后终于该用上goquery了，拿到标题，然后遍历文章内容中的img标签，就拿到了每一篇文章的每一张图片。</p>

<h4>4. 保存图片</h4>

<p>在上一步把图片地址和文章名称传递给了getImgAndSave。</p>

<pre><code class="language-go">func getImgAndSave(url string, dirname string) {
	path := strings.Split(url, &quot;/&quot;)
	var name string
	if len(path) &gt; 1 {
		name = path[len(path)-1]
	}

	resp, err := http.Get(url)
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		log.Fatal(&quot;请求失败&quot;, err)
		return
	}

	contents, err := ioutil.ReadAll(resp.Body)
	defer func() {
		if x := recover(); x != nil {
			return
		}
	}()
	err = ioutil.WriteFile(&quot;./&quot;+tag+&quot;/&quot;+dirname+&quot;/&quot;+name+&quot;.jpg&quot;, contents, 0644)
	if err != nil {
		log.Fatal(&quot;写入文件失败&quot;, err)
	}
}
</code></pre>

<p>先分割图片链接，把最后一个&rdquo;/&ldquo;后的内容当成文件名。</p>

<p>后边get图片内容，但是有时候会出现对方服务器出错的情况，http状态码为500，所以加了判断请求是否成功的判断。</p>

<p>然后就是读取内容，保存到文件中了。</p>

<p>这里使用了WriteFile方式，查资料的时候还看到有闲Create文件，然后io.Copy写入的。</p>

<h4>到这里就结束了。</h4>

<h3>RUN</h3>

<pre><code>go run main.go 美女 模特
</code></pre>

<p>等着看图吧。</p>

<p>github地址：<a href="https://github.com/qichengzx/toutiaoSpider">toutiaoSpider</a>，欢迎star。</p>

                    </div>
                    <footer class="article-footer">
                      <a href="https://www.qichengzx.com/2016/12/14/toutiao-images-spider-by-golang.html#comments" class="article-comment-link">Comments</a>
                      
                        <ul class="article-tag-list">
                        
                          <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/go">go</a>
                          </li>
                        
                          <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/%e4%bb%8a%e6%97%a5%e5%a4%b4%e6%9d%a1">今日头条</a>
                          </li>
                        
                          <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/goquery">goquery</a>
                          </li>
                        
                        </ul>
                      
                    </footer>
                  </div>
                  <nav id="article-nav">
                    

                    
                  </nav>
                </article>

        
        
                <article id="c3944b0882070ad3a784fa6fc304b7af" class="article" itemscope itemprop="blogPost">
                  <div class="article-meta">
                    <a href="https://www.qichengzx.com/2016/12/04/go-qiubai.html" class="article-date">
                      <time itemprop="datePublished">2016-12-04 15:49:04</time>
                    </a>
                    <div class="article-category">
                      <a class="article-category-link" href="/categories/golang">golang</a>
                    </div>
                  </div>
                  <div class="article-inner">
                    <header class="article-header">
                      <h1 itemprop="name">
                        <a class="article-title" href="https://www.qichengzx.com/2016/12/04/go-qiubai.html">Go语言写爬取糗百热门帖子</a>
                      </h1>
                    </header>
                    <div class="article-entry" itemprop="articleBody">
                      <p>闲来无事，想着也用Go来写个爬虫之类的东西，我并不知道这算不算严格意义上的爬虫。</p>

<p>思前想后，觉得写个爬糗百热门的脚本吧，一来足够简单，二来大概熟悉下流程。</p>

<p>首先，选了<a href="https://github.com/PuerkitoBio/goquery">goquery</a>这个包来解析HTML，声称与jquery相似的用法，事实上也确实是这样，非常方便。</p>

<p>定个目标，只爬取列表页的帖子内容，作者和回帖都不管。</p>

<pre><code>package main

import (
	&quot;github.com/PuerkitoBio/goquery&quot;
	&quot;log&quot;
)

//定义结构体
type Qb struct {
	Id int `json:&quot;id&quot;`
	Content string `json:&quot;content&quot;`
}

func main() {
	var url = &quot;http://www.qiushibaike.com/hot&quot;

	doc, err := goquery.NewDocument(url)
	if err != nil {
		log.Fatal(err)
	}

	var qb []Qb
	doc.Find(&quot;#content-left .article&quot;).Each(func(i int, s *goquery.Selection) {
		//s即为当前的 .article 元素，查找下级中的span元素的内容。
		content := s.Find(&quot;.content span&quot;).Text()
		qb = append(qb, Qb{Id: i, Content: content})
	})

	log.Println(qb)
}
</code></pre>

<p>&rdquo;#content-left .article&rdquo; 即每一条帖子作为元素的class。</p>

<p>将会输出：</p>

<pre><code>[
	{0 结婚十三周年那天，老婆望着一大桌子菜不禁泪流满面。我帮她拭去泪水:瞧你，都激动的哭了!老婆却说:我激动个屁!想想这十三年跟着你受的罪，我实在忍不住啊!} 
	{1 前几天天冷，就给妹妹买了条围巾，然后她说谢谢哥，本人本着组织精神说你应该谢谢你嫂子，她惊讶的对我说:哥，你谈女朋友了。我说:没有，你应该感谢她一直到现在都没出现，哥才有钱给你买东西} 
	{2 跟哥们去理发，剪头的是个妹纸。。妹纸:“你有女朋友么？”哥们一听，突然兴奋的说:“没有！”妹纸:“我是个实习生，本来想给你换大工的，看你没有女朋友，我就随意剪了！”哥们你别看我，我就是一口水没忍住，喷你脸上了而已！} 
	{3 老妈比较胖，小时候每次打我我都是撒腿就跑，老妈没一次抓到我的。直到老妈学会骑自行车以后，那鞭子挥得………真像套马杆的汉子，威武雄壮……}
]
</code></pre>

<p>那么如何展示到页面中呢。</p>

<p>我选择了 <a href="https://github.com/gin-gonic/gin">gin</a> 框架。</p>

<p>修改一下代码。</p>

<pre><code>func main() {
	r := gin.Default()
	r.LoadHTMLGlob(&quot;public/*&quot;)
	r.GET(&quot;/&quot;, Index)
	r.Run()
}

func Index(c *gin.Context) {
	var url = &quot;http://www.qiushibaike.com/hot&quot;

	doc, err := goquery.NewDocument(url)
	if err != nil {
		log.Fatal(err)
	}

	var result []Qb
	doc.Find(&quot;#content-left .article&quot;).Each(func(i int, s *goquery.Selection) {
		content := s.Find(&quot;.content span&quot;).Text()
		result = append(result, Qb{Id: i, Content: content})
	})

	c.HTML(http.StatusOK, &quot;index.html&quot;, gin.H{
		&quot;items&quot;: result,
		&quot;title&quot;: &quot;糗百热门&quot;
	})
}
</code></pre>

<p>可以看到，</p>

<pre><code>r := gin.Default()
r.LoadHTMLGlob(&quot;public/*&quot;)
r.GET(&quot;/&quot;, Index)
</code></pre>

<p>这里加载了public目录中的模板，然后下一行，表示，接收到 &ldquo;/&rdquo; 的请求时，调用Index方法去处理。</p>

<p>到这里，文档的抓取，解析，构造数据就已经完成，下一步，看一下怎么显示到页面中。</p>

<pre><code>{% raw %}
&lt;div class=&quot;col-md-12&quot;&gt;
    &lt;h2&gt;{{ .title }}&lt;/h2&gt;
    &lt;table class=&quot;table table-striped table-bordered table-hover&quot;&gt;
        {{ range $item := .items }}
        &lt;tr&gt;
            &lt;td&gt;{{ $item.Content }}&lt;/td&gt;
        &lt;/tr&gt;
        {{ end }}
    &lt;/table&gt;
&lt;/div&gt;
{% endraw %}
</code></pre>

<p>使用 &ldquo;{% raw %}{{ }}{% endraw %}&rdquo; 输出后端发送过来的数据。使用 range 迭代数据。与</p>

<pre><code>for pos, char := range str {
...
}
</code></pre>

<p>一样。</p>

<p>完整的模板代码：</p>

<pre><code>{% raw %}
&lt;!-- public/index.html --&gt;

&lt;html&gt;
    &lt;head&gt;
        &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no&quot;&gt;
        &lt;title&gt;糗百&lt;/title&gt;

        &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.bootcss.com/bootstrap/3.3.6/css/bootstrap.min.css&quot;&gt;
        &lt;link rel=&quot;stylesheet&quot;  href=&quot;https://cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css&quot;&gt;

    &lt;/head&gt;
    &lt;body&gt;
        &lt;div class=&quot;container&quot;&gt;
            &lt;div class=&quot;row&quot;&gt;
                &lt;div class=&quot;col-md-12&quot;&gt;
                    &lt;h2&gt;{{ .title }}&lt;/h2&gt;
                    &lt;table class=&quot;table table-striped table-bordered table-hover&quot;&gt;
                        {{ range $item := .items }}
                        &lt;tr&gt;
                            &lt;td&gt;{{ $item.Content }}&lt;/td&gt;
                        &lt;/tr&gt;
                        {{ end }}
                    &lt;/table&gt;
                &lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    &lt;/body&gt;
&lt;/html&gt;
{% endraw %}
</code></pre>

<p>这样，运行一下，就可以了。</p>

<p>gin框架默认使用8080端口，打开 <a href="http://localhost:8080">http://localhost:8080</a> 就可以看到一个极简版的糗百热门了。</p>

<p>问题来了，怎么增加一个分页呢？</p>

<p>完整代码见:</p>

<p><a href="https://github.com/qichengzx/goqiubai">Github地址</a></p>

<h4>后记</h4>

<p>其实早就写完了这篇，但是hexo生成的时候由于 <a href="https://hexo.io/docs/troubleshooting.html#Escape-Contents">&rdquo;{% raw %}{{{% endraw %}&ldquo;的问题</a>，生成一直失败，一直拖到现在。</p>

<p>实际代码中需要去掉 &ldquo;{ % raw % }&rdquo; 相关部分。</p>

                    </div>
                    <footer class="article-footer">
                      <a href="https://www.qichengzx.com/2016/12/04/go-qiubai.html#comments" class="article-comment-link">Comments</a>
                      
                        <ul class="article-tag-list">
                        
                          <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/go">go</a>
                          </li>
                        
                          <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/%e7%b3%97%e7%99%be">糗百</a>
                          </li>
                        
                          <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/goquery">goquery</a>
                          </li>
                        
                          <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/gin">gin</a>
                          </li>
                        
                        </ul>
                      
                    </footer>
                  </div>
                  <nav id="article-nav">
                    

                    
                  </nav>
                </article>

        
        
                <article id="21b1d6bb006767ea7ba5a2566c9d7e1b" class="article" itemscope itemprop="blogPost">
                  <div class="article-meta">
                    <a href="https://www.qichengzx.com/2016/11/02/install-yaf-on-mac.html" class="article-date">
                      <time itemprop="datePublished">2016-11-02 17:57:38</time>
                    </a>
                    <div class="article-category">
                      <a class="article-category-link" href="/categories/php">php</a>
                    </div>
                  </div>
                  <div class="article-inner">
                    <header class="article-header">
                      <h1 itemprop="name">
                        <a class="article-title" href="https://www.qichengzx.com/2016/11/02/install-yaf-on-mac.html">Mac brew php7.1环境下安装Yaf</a>
                      </h1>
                    </header>
                    <div class="article-entry" itemprop="articleBody">
                      <p><img src="/images/php/think201-emergence-of-php7.jpg" alt="" /></p>

<p>开发机一直使用brew来安装PHP及其他的环境，今天把PHP升到7.1，由于7.1版本下还没有<a href="http://www.laruence.com/manual/">yaf</a>的源，所以无法使用brew安装，只能编译安装了。</p>

<p>首先下载yaf，解压，进入目录。</p>

<pre><code>git clone git@github.com:laruence/yaf.git

$(brew --prefix homebrew/php/php71)/bin/phpize

./configure --with-php-config=$(brew --prefix homebrew/php/php71)/bin/php-config

make &amp;&amp; make install

make test

</code></pre>

<p>$(brew &ndash;prefix homebrew/php/php71) 即 brew info php71结果中的path值。</p>

<p>由于brew安装PHP会在php.ini同级目录创建conf.d目录，并把扩展的配置文件写在这里，一目了然知道都安装了哪些扩展，所以也以同样方式在此目录创建ext-yaf.ini。</p>

<p>make install 后会显示，具体路径可能会不一样。</p>

<pre><code>Installing shared extensions:     /usr/local/Cellar/php71/7.1.0-rc.5_9/lib/php/extensions/no-debug-non-zts-20160303/
</code></pre>

<p>这个目录即扩展.so的存放目录。下边会用到。</p>

<pre><code>[yaf]
extension=&quot;/usr/local/opt/php71/lib/php/extensions/no-debug-non-zts-20160303/yaf.so&quot;
yaf.environ=&quot;dev&quot;
;yaf.use_namespace = 1
</code></pre>

<p>至此，重启php-fpm就可以了。</p>

<p>图片来自：<a href="https://think201.com/blog/2016/emergence-of-php7/">Emergence of PHP7</a></p>

                    </div>
                    <footer class="article-footer">
                      <a href="https://www.qichengzx.com/2016/11/02/install-yaf-on-mac.html#comments" class="article-comment-link">Comments</a>
                      
                        <ul class="article-tag-list">
                        
                          <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/php">php</a>
                          </li>
                        
                        </ul>
                      
                    </footer>
                  </div>
                  <nav id="article-nav">
                    

                    
                  </nav>
                </article>

        
        
                <article id="c5fa95094cfb7a0da8abdcbe35816973" class="article" itemscope itemprop="blogPost">
                  <div class="article-meta">
                    <a href="https://www.qichengzx.com/2016/10/21/beego-in-docker.html" class="article-date">
                      <time itemprop="datePublished">2016-10-21 10:02:02</time>
                    </a>
                    <div class="article-category">
                      <a class="article-category-link" href="/categories/golang">golang</a>
                    </div>
                  </div>
                  <div class="article-inner">
                    <header class="article-header">
                      <h1 itemprop="name">
                        <a class="article-title" href="https://www.qichengzx.com/2016/10/21/beego-in-docker.html">用Docker部署Golang Beego框架应用</a>
                      </h1>
                    </header>
                    <div class="article-entry" itemprop="articleBody">
                      <p>Docker是什么就不说了。
Golang是什么也不说了。
Beego是什么就更不用说了。</p>

<p>最近Beego项目完成，研究怎么部署。因为Docker部署起来更简单更快速，所以就说下怎么在docker里部署beego应用。</p>

<h4>写在前面</h4>

<p>假设你的应用路径为 /go/app；
假设已配置好docker的相关东西。
假设使用 <a href="https://github.com/tools/godep">godep</a> 作为依赖管理工具
示例中开放端口为80，需要与app.conf中的端口一致，可以自行修改。</p>

<h4>配置</h4>

<p>在 /go/app 目录新建Dockerfile。</p>

<pre><code>FROM golang:1.7.1-alpine

MAINTAINER youremail &lt;youremail@xxx.com&gt;

RUN apk add --update go git

ADD ./ /go/src/app

RUN cd /go/src/app \
	&amp;&amp; go get github.com/astaxie/beego \
	&amp;&amp; go get github.com/tools/godep \
	&amp;&amp; godep update -goversion \
	&amp;&amp; godep get \
	&amp;&amp; godep save \
	&amp;&amp; go build

EXPOSE 80

EXTRYPOINT /go/src/app/app
</code></pre>

<p>本例使用 golang:1.7.1-alpine 作为基础镜像。golang的所有镜像见<a href="https://hub.docker.com/_/golang/">这里</a>。</p>

<h4>构建</h4>

<pre><code>docker build -t app .
</code></pre>

<h4>运行</h4>

<pre><code>docker run -d -p 8080:80 app
</code></pre>

<h4>访问</h4>

<p>使用nginx反向代理访问docker中的go应用。</p>

<pre><code>server {
    listen       80;
    server_name  app.com;

    charset utf-8;
    access_log  logs/app.access.log;

    location / {
        try_files /_not_exists_ @backend;
    }
    if (!-e $request_filename) {
        return 404;
    }

    location @backend {
        proxy_set_header X-Forwarded-For $remote_addr;
        proxy_set_header Host            $http_host;

        proxy_pass http://192.168.99.100:8080; // 192.168.99.100为docker machine的ip,8080为 docker run 时指定的本地端口。
    }
}
</code></pre>

<h4>相关资料</h4>

<p><a href="https://yq.aliyun.com/articles/57247">如何使用Docker快速部署go-web应用程序</a>
<a href="https://blog.golang.org/docker">Deploying Go servers with Docker</a>
<a href="http://www.infoq.com/cn/articles/how-to-deploy-a-go-web-application-with-docker?utm_source=infoq&amp;utm_medium=related_content_link&amp;utm_campaign=relatedContent_articles_clk">如何使用Docker部署Go Web应用程序</a>
<a href="https://www.iron.io/the-easiest-way-to-develop-with-go%E2%80%8A-%E2%80%8Aintroducing-a-docker-based-go-tool/">The Easiest Way to Develop with Go — Introducing a Docker Based Go Tool</a>
<a href="https://semaphoreci.com/community/tutorials/how-to-deploy-a-go-web-application-with-docker">How To Deploy a Go Web Application with Docker</a>
<a href="https://beego.me/docs/deploy/nginx.md">nginx 部署</a></p>

                    </div>
                    <footer class="article-footer">
                      <a href="https://www.qichengzx.com/2016/10/21/beego-in-docker.html#comments" class="article-comment-link">Comments</a>
                      
                        <ul class="article-tag-list">
                        
                          <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/go">go</a>
                          </li>
                        
                        </ul>
                      
                    </footer>
                  </div>
                  <nav id="article-nav">
                    

                    
                  </nav>
                </article>

        
        
                <article id="5e80b78290d36efba7bf0f1803f6197e" class="article" itemscope itemprop="blogPost">
                  <div class="article-meta">
                    <a href="https://www.qichengzx.com/2016/09/28/custom-data-pagination-in-laravel-with-arrays.html" class="article-date">
                      <time itemprop="datePublished">2016-09-28 15:43:13</time>
                    </a>
                    <div class="article-category">
                      <a class="article-category-link" href="/categories/php">php</a>
                    </div>
                  </div>
                  <div class="article-inner">
                    <header class="article-header">
                      <h1 itemprop="name">
                        <a class="article-title" href="https://www.qichengzx.com/2016/09/28/custom-data-pagination-in-laravel-with-arrays.html">Laravel 手动创建分页</a>
                      </h1>
                    </header>
                    <div class="article-entry" itemprop="articleBody">
                      <p>有些情况下会从接口读取数据，数据较多时会用到分页，Laravel为这种需求提供了很方便的方法。</p>

<p><a href="https://laravel.com/docs/5.2/pagination">官方文档</a>里几句略过，并没有详细说明，经过查找资料，发现如下方法可行。</p>

<h3>首先use LengthAwarePaginator</h3>

<pre><code class="language-php">use Illuminate\Pagination\LengthAwarePaginator;
use Illuminate\Support\Collection;
</code></pre>

<p>假设原内容是：</p>

<pre><code class="language-php">$result = [
    'item1',
    'item2',
    'item3',
    'item4',
    'item5',
    'item6',
];
</code></pre>

<p>对于一个列表来说，item一般会是个array，这里忽略。</p>

<h3>情况1，已知总数，只有部分数据</h3>

<p>由于本人所使用的接口有页码和每页数量的参数，所以每次查询返回的其实就是每一页的内容了，而接口又返回了符合条件的总数count，所以使用如下方式即可：</p>

<pre><code class="language-php">$perPage = 10;
$count = 100;//假设这里是接口返回的总数
//创建collection
$collection = new Collection($data);

$currentPageResults = $collection-&gt;all();

//生成分页
$data = new LengthAwarePaginator($currentPageResults, $count, $perPage);
//设置分页的链接
$data-&gt;setPath($request-&gt;url());
</code></pre>

<h3>情况2，未知总数，有全部数据</h3>

<p>而如果$data是全部数据呢，比如100条数据全部返回，然后要生成一个每页10条记录的分页，可以这样做：</p>

<pre><code class="language-php">//获取当前页码
$currentPage = LengthAwarePaginator::resolveCurrentPage();

//从数组创建一个laravel collection
$collection = new Collection($searchResults);

//设置每页数量
$perPage = 10;

//从collection分割数据
$currentPageSearchResults = $collection-&gt;slice($currentPage * $perPage, $perPage)-&gt;all();

//生成分页
$paginatedSearchResults= new LengthAwarePaginator($currentPageSearchResults, count($collection), $perPage);
//设置分页的链接
$data-&gt;setPath($request-&gt;url());
</code></pre>

<h3>区别</h3>

<p>其实两者只是相差了一次分割数据。</p>

<h3>最后</h3>

<p>在视图里依然使用</p>

<pre><code>{!! $data-&gt;render() !!}
</code></pre>

<p>输出分页组件。</p>

<p>看起来还挺简单的。</p>

<h3>参考链接：</h3>

<p><a href="https://laravel.com/docs/5.2/pagination">官方文档pagination</a></p>

<p><a href="http://psampaz.github.io/custom-data-pagination-with-laravel-5/">Custom data pagination with Laravel 5</a></p>

<p><a href="http://www.acekyd.com/2016/02/28/custom-pagination-view-in-laravel-5-with-arrays/">CUSTOM PAGINATION VIEW IN LARAVEL 5 WITH ARRAYS</a></p>

                    </div>
                    <footer class="article-footer">
                      <a href="https://www.qichengzx.com/2016/09/28/custom-data-pagination-in-laravel-with-arrays.html#comments" class="article-comment-link">Comments</a>
                      
                        <ul class="article-tag-list">
                        
                          <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/php">php</a>
                          </li>
                        
                          <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/laravel">laravel</a>
                          </li>
                        
                        </ul>
                      
                    </footer>
                  </div>
                  <nav id="article-nav">
                    

                    
                  </nav>
                </article>

        
        
                <article id="20dc7a4d7acd076d813c37a19293c4e1" class="article" itemscope itemprop="blogPost">
                  <div class="article-meta">
                    <a href="https://www.qichengzx.com/2016/09/16/convert-xml-to-json-in-golang.html" class="article-date">
                      <time itemprop="datePublished">2016-09-16 11:28:20</time>
                    </a>
                    <div class="article-category">
                      <a class="article-category-link" href="/categories/golang">golang</a>
                    </div>
                  </div>
                  <div class="article-inner">
                    <header class="article-header">
                      <h1 itemprop="name">
                        <a class="article-title" href="https://www.qichengzx.com/2016/09/16/convert-xml-to-json-in-golang.html">Golang XMl 转 JSON</a>
                      </h1>
                    </header>
                    <div class="article-entry" itemprop="articleBody">
                      <p><img src="/images/golang.png" alt="" /></p>

<h4>起因</h4>

<p>某个上古时代的API，依然在返回XML格式的数据，更奇葩的是，GBK格式的。</p>

<p>用Go顺利的写到了发送数据，接收数据，然后取值有点麻烦啊。。。。</p>

<p>各种Google后，终于解决，但是不保证是唯一，正确，最合适的答案。</p>

<h4>说在前边</h4>

<p>本文假设要解析的XMl数据为：</p>

<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;GBK&quot; ?&gt;
&lt;response&gt;
    &lt;status&gt;200&lt;/status&gt;
&lt;/response&gt;
</code></pre>

<p>要解决的问题是取出“200”这个状态值。</p>

<h4>导入包</h4>

<p>解析XML使用了&rdquo;encoding/xml&rdquo;这个包。</p>

<p>所以先导入这个包。</p>

<pre><code class="language-go">import &quot;encoding/xml&quot;
</code></pre>

<h4>定义struct</h4>

<p>定义一个自定义类型的Response</p>

<pre><code class="language-go">type Response struct {
    Status int `xml:&quot;status&quot; json:&quot;status&quot;`
}
</code></pre>

<p>定义一个Response类型的变量</p>

<pre><code class="language-go">var result Response
</code></pre>

<h4>偷懒转格式</h4>

<p>因为&rdquo;encoding/xml&rdquo;不支持GBK格式的XML，而返回的内容又固定标明了编码是GBK，所以这里偷懒，直接把GBK替换成UTF-8，本例中不影响结果。</p>

<pre><code class="language-go">xmlstr := `?xml version=&quot;1.0&quot; encoding=&quot;GBK&quot; ?&gt;
&lt;response&gt;
    &lt;status&gt;200&lt;/status&gt;
&lt;/response&gt;
`
xmlstr = strings.Replace(xmlstr, &quot;GBK&quot;, &quot;UTF-8&quot;, -1)
</code></pre>

<p>使用strings包，替换“GBK”，相信根据参数顺序能看出各个参数的意义，最后一个参数：-1，为替换全部，即字符串中所有出现的第二个参数全部替换。</p>

<h4>解析，转换，取值</h4>

<p>使用encoding/jon，go-simplejson包</p>

<pre><code class="language-go">//解析XML
err := xml.Unmarshal([]byte(xmlstr), &amp;result)

if nil != err {
  log.Fatal(err)
}
log.Printf(&quot;XML:%v \n&quot;, result) 

//转换成JSON
res, err := json.Marshal(result)

if nil != err {
  log.Fatal(err)
}
log.Printf(&quot;JSON:%s \n&quot;, res)

js, err := simplejson.NewJson([]byte(res))

if nil != err {
  log.Fatal(err)
}
status, err := js.Get(&quot;status&quot;).Int()

log.Printf(&quot;STATUS:%v \n&quot;, status)
</code></pre>

<p>以上是本人在处理XML 转 JSON 时的解决办法，应该还有更简单更合适的方案。仅供参考。</p>

<h4>完整代码：</h4>

<pre><code class="language-go">package main
import (
    &quot;encoding/xml&quot;
    &quot;encoding/json&quot;
    &quot;log&quot;
    &quot;strings&quot;
    simplejson &quot;github.com/bitly/go-simplejson&quot;
)
type Response struct {
    Status int `xml:&quot;status&quot; json:&quot;status&quot;`
}

func main() {
    
    var result Response

    //多行字符串，使用反引号`
    xmlstr := `&lt;?xml version=&quot;1.0&quot; encoding=&quot;GBK&quot; ?&gt;
&lt;response&gt;
    &lt;status&gt;200&lt;/status&gt;
&lt;/response&gt;`

    xmlstr = strings.Replace(xmlstr, &quot;GBK&quot;, &quot;UTF-8&quot;, -1)

    err := xml.Unmarshal([]byte(xmlstr), &amp;result)
    if err != nil {
        log.Fatal(err)
    }
    log.Printf(&quot;XML:%v&quot;,result)

    r, err := json.Marshal(result)
    if nil != err {
        log.Fatal(err)
    }

    log.Printf(&quot;JSON:%s&quot;, r)

    js, err := simplejson.NewJson([]byte(r))

    if nil != err {
        log.Fatal(err)
    }
    status, err := js.Get(&quot;status&quot;).Int()
    log.Printf(&quot;VALUE:%v&quot;,status)

}
</code></pre>

<h4>发现问题：</h4>

<p>今天（2016-09-18），再看这段代码，发现跟另一个程序里有些不一样。</p>

<p>另一个程序里是这样的：</p>

<pre><code>type Response struct {
    Status int `xml:&quot;status&quot;
}
</code></pre>

<p>也可以正常返回值，但是在本文中的示例却不能正常输出status值，而是会输出空，看了半天发现，使用 log 时：</p>

<pre><code>log.Printf(&quot;VALUE:%v&quot;,status)
</code></pre>

<p>如果struct没有写
“json:&ldquo;status&rdquo;”，就不能输出，如果换成fmt，struct就可以不写“json:&ldquo;status&rdquo;。结果是一样的，其中的原因还要再查资料研究下。</p>

<p>参考文章：</p>

<p><a href="http://blog.studygolang.com/2012/12/%e6%a0%87%e5%87%86%e5%ba%93-xml%e5%a4%84%e7%90%86%ef%bc%88%e4%b8%80%ef%bc%89/">标准库—XML处理（一）</a></p>

<p><a href="https://play.golang.org/p/7HNLEUnX-m">https://play.golang.org/p/7HNLEUnX-m</a></p>

<p><a href="https://play.golang.org/p/m99B12RaLe">https://play.golang.org/p/m99B12RaLe</a></p>

<p><a href="https://astaxie.gitbooks.io/build-web-application-with-golang/content/zh/07.1.html">XML处理</a></p>

                    </div>
                    <footer class="article-footer">
                      <a href="https://www.qichengzx.com/2016/09/16/convert-xml-to-json-in-golang.html#comments" class="article-comment-link">Comments</a>
                      
                        <ul class="article-tag-list">
                        
                          <li class="article-tag-list-item">
                            <a class="article-tag-list-link" href="/tags/go">go</a>
                          </li>
                        
                        </ul>
                      
                    </footer>
                  </div>
                  <nav id="article-nav">
                    

                    
                  </nav>
                </article>

        

        
        


<nav id="page-nav">






  <a class="extend prev" rel="prev" href="/page/2/">« Prev</a>





  <a class="page-number" href="/">1</a>



  <a class="page-number" href="/page/2/">2</a>



  <span class="page-number current">3</span>



  <a class="page-number" href="/page/4/">4</a>



  <a class="page-number" href="/page/5/">5</a>



  <a class="page-number" href="/page/6/">6</a>




  <a class="extend next" rel="next" href="/page/4/">Next »</a>

</nav>


        
      
      </section>
      
      
            <aside id="sidebar">
            
    
                <div class="widget-wrap">
                  <h3 class="widget-title">Categories</h3>
                  <div class="widget">
                    <ul class="category-list">
                      
                      
                      <li class="category-list-item">
                        <a class="category-list-link" href="/categories/default/">default</a>
                        <span class="category-list-count">7</span>
                      </li>
                      
                      <li class="category-list-item">
                        <a class="category-list-link" href="/categories/git/">git</a>
                        <span class="category-list-count">3</span>
                      </li>
                      
                      <li class="category-list-item">
                        <a class="category-list-link" href="/categories/golang/">golang</a>
                        <span class="category-list-count">22</span>
                      </li>
                      
                      <li class="category-list-item">
                        <a class="category-list-link" href="/categories/javascript/">javascript</a>
                        <span class="category-list-count">7</span>
                      </li>
                      
                      <li class="category-list-item">
                        <a class="category-list-link" href="/categories/linux/">linux</a>
                        <span class="category-list-count">1</span>
                      </li>
                      
                      <li class="category-list-item">
                        <a class="category-list-link" href="/categories/mysql/">mysql</a>
                        <span class="category-list-count">4</span>
                      </li>
                      
                      <li class="category-list-item">
                        <a class="category-list-link" href="/categories/nginx/">nginx</a>
                        <span class="category-list-count">1</span>
                      </li>
                      
                      <li class="category-list-item">
                        <a class="category-list-link" href="/categories/php/">php</a>
                        <span class="category-list-count">12</span>
                      </li>
                      
                    </ul>
                  </div>
                </div>
    

            
    
                <div class="widget-wrap">
                  <h3 class="widget-title">Tags</h3>
                  <div class="widget">
                    <ul class="tag-list">
                      
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/ECharts/">ECharts</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/Keygen/">Keygen</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/captcha/">captcha</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/crontab/">crontab</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/discuz/">discuz</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/docker/">docker</a>
                        <span class="tag-list-count">2</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/dropbox/">dropbox</a>
                        <span class="tag-list-count">2</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/excel/">excel</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/fetch/">fetch</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/geo/">geo</a>
                        <span class="tag-list-count">3</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/gin/">gin</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/git/">git</a>
                        <span class="tag-list-count">3</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/github/">github</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/go/">go</a>
                        <span class="tag-list-count">21</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/goquery/">goquery</a>
                        <span class="tag-list-count">2</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/hexo/">hexo</a>
                        <span class="tag-list-count">3</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/https/">https</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/input/">input</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/javascript/">javascript</a>
                        <span class="tag-list-count">3</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/js/">js</a>
                        <span class="tag-list-count">2</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/laravel/">laravel</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/leetcode/">leetcode</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/linux/">linux</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/mysql/">mysql</a>
                        <span class="tag-list-count">7</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/nginx/">nginx</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/node/">node</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/pdo/">pdo</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/php/">php</a>
                        <span class="tag-list-count">14</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/qq/">qq</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/rabbitmq/">rabbitmq</a>
                        <span class="tag-list-count">6</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/react-native/">react-native</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/redigo/">redigo</a>
                        <span class="tag-list-count">3</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/redis/">redis</a>
                        <span class="tag-list-count">5</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/ssl/">ssl</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/time/">time</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/vps/">vps</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/vue/">vue</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/widget/">widget</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/%e4%bb%8a%e6%97%a5%e5%a4%b4%e6%9d%a1/">今日头条</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/%e6%a0%87%e8%af%86%e7%ac%a6/">标识符</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/%e7%88%b1%e5%a5%87%e8%89%ba/">爱奇艺</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/%e7%9f%ad%e7%bd%91%e5%9d%80/">短网址</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/%e7%b3%97%e7%99%be/">糗百</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/%e7%bd%91%e7%bb%9c%e8%af%b7%e6%b1%82/">网络请求</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                      <li class="tag-list-item">
                        <a class="tag-list-link" href="/tags/%e9%98%9f%e5%88%97/">队列</a>
                        <span class="tag-list-count">1</span>
                      </li>
                      
                    </ul>
                  </div>
                </div>
    

            
    
            <div class="widget-wrap">
              <h3 class="widget-title">Archives</h3>
              <div class="widget">
                <ul class="archive-list">
                  
                  
                  <li class="archive-list-item">
                    <a class="archive-list-link" href="/archives/2015/11">2015/11</a>
                    <span class="archive-list-count">7</span>
                  </li>
                  
                  <li class="archive-list-item">
                    <a class="archive-list-link" href="/archives/2015/12">2015/12</a>
                    <span class="archive-list-count">4</span>
                  </li>
                  
                  <li class="archive-list-item">
                    <a class="archive-list-link" href="/archives/2016/01">2016/01</a>
                    <span class="archive-list-count">3</span>
                  </li>
                  
                  <li class="archive-list-item">
                    <a class="archive-list-link" href="/archives/2016/02">2016/02</a>
                    <span class="archive-list-count">4</span>
                  </li>
                  
                  <li class="archive-list-item">
                    <a class="archive-list-link" href="/archives/2016/04">2016/04</a>
                    <span class="archive-list-count">4</span>
                  </li>
                  
                  <li class="archive-list-item">
                    <a class="archive-list-link" href="/archives/2016/05">2016/05</a>
                    <span class="archive-list-count">3</span>
                  </li>
                  
                  <li class="archive-list-item">
                    <a class="archive-list-link" href="/archives/2016/07">2016/07</a>
                    <span class="archive-list-count">1</span>
                  </li>
                  
                  <li class="archive-list-item">
                    <a class="archive-list-link" href="/archives/2016/09">2016/09</a>
                    <span class="archive-list-count">3</span>
                  </li>
                  
                  <li class="archive-list-item">
                    <a class="archive-list-link" href="/archives/2016/10">2016/10</a>
                    <span class="archive-list-count">1</span>
                  </li>
                  
                  <li class="archive-list-item">
                    <a class="archive-list-link" href="/archives/2016/11">2016/11</a>
                    <span class="archive-list-count">1</span>
                  </li>
                  
                  <li class="archive-list-item">
                    <a class="archive-list-link" href="/archives/2016/12">2016/12</a>
                    <span class="archive-list-count">3</span>
                  </li>
                  
                  <li class="archive-list-item">
                    <a class="archive-list-link" href="/archives/2017/03">2017/03</a>
                    <span class="archive-list-count">1</span>
                  </li>
                  
                  <li class="archive-list-item">
                    <a class="archive-list-link" href="/archives/2017/06">2017/06</a>
                    <span class="archive-list-count">1</span>
                  </li>
                  
                  <li class="archive-list-item">
                    <a class="archive-list-link" href="/archives/2017/07">2017/07</a>
                    <span class="archive-list-count">2</span>
                  </li>
                  
                  <li class="archive-list-item">
                    <a class="archive-list-link" href="/archives/2017/08">2017/08</a>
                    <span class="archive-list-count">1</span>
                  </li>
                  
                  <li class="archive-list-item">
                    <a class="archive-list-link" href="/archives/2017/09">2017/09</a>
                    <span class="archive-list-count">3</span>
                  </li>
                  
                  <li class="archive-list-item">
                    <a class="archive-list-link" href="/archives/2017/11">2017/11</a>
                    <span class="archive-list-count">1</span>
                  </li>
                  
                  <li class="archive-list-item">
                    <a class="archive-list-link" href="/archives/2018/02">2018/02</a>
                    <span class="archive-list-count">4</span>
                  </li>
                  
                  <li class="archive-list-item">
                    <a class="archive-list-link" href="/archives/2018/04">2018/04</a>
                    <span class="archive-list-count">2</span>
                  </li>
                  
                  <li class="archive-list-item">
                    <a class="archive-list-link" href="/archives/2018/05">2018/05</a>
                    <span class="archive-list-count">6</span>
                  </li>
                  
                  <li class="archive-list-item">
                    <a class="archive-list-link" href="/archives/2018/06">2018/06</a>
                    <span class="archive-list-count">1</span>
                  </li>
                  
                  <li class="archive-list-item">
                    <a class="archive-list-link" href="/archives/2019/01">2019/01</a>
                    <span class="archive-list-count">1</span>
                  </li>
                  
                </ul>
              </div>
            </div>
    

            
    
            <div class="widget-wrap">
              <h3 class="widget-title">RECENTS</h3>
              <div class="widget">
                <ul>
                  
                  <li>
                    <a href="https://www.qichengzx.com/2019/01/01/go-in-the-browser.html">【译】Go和WebAssembly：在浏览器中运行Go程序</a>
                  </li>
                  
                  <li>
                    <a href="https://www.qichengzx.com/2018/06/15/qq-007-captcha.html">腾讯防水墙验证码使用</a>
                  </li>
                  
                  <li>
                    <a href="https://www.qichengzx.com/2018/05/29/git-pull-upstream.html">Git 同步上游源更改</a>
                  </li>
                  
                  <li>
                    <a href="https://www.qichengzx.com/2018/05/13/create-a-single-page-app-with-go-echo-and-vue.html">【译】使用 Go，Echo 和 Vue 创建单页 TODO 应用</a>
                  </li>
                  
                  <li>
                    <a href="https://www.qichengzx.com/2018/05/12/generating-random-keys-with-keygen.html">Keygen 包简介</a>
                  </li>
                  
                </ul>
              </div>
            </div>
    

            </aside>

      
    </div>
    
        <footer id="footer">
          <div class="outer">
            <div id="footer-info" class="inner">
              &copy; 2019 启程<br>
              Powered by <a href="https://github.com/qichengzx/gopress" target="_blank">gopress</a>
            </div>
            </div>
        </footer>

  </div>
  
<nav id="mobile-nav">
  
  <a class="mobile-nav-link" href="/">Home</a>
  
  <a class="mobile-nav-link" href="/archives">Archives</a>
  
  <a class="mobile-nav-link" href="https://github.com">GitHub</a>
  
</nav>

  

<script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script>


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>


</div>
</body>
</html>
