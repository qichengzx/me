title: 一个匹配URL的JS正则表达式
date: 2015-11-16 22:02:23
tags:  [js,url,正则]
---

```
var parse_url = /^(?:([A-Za-z]+):)?(\/{0,3})([0-9.\-A-Za-z]+)(?::(\d+))?(?:\/([^?#]*))?(?:\?([^#]*))?(?:#(.*))?$/;
var url = "http://www.ora.com:80/goodparts?q#fragment";
```

现在我们调用parse_url的exec方法，如果成功匹配了url这个字符串，它会返回一个数组，这个数组包含从这个url中取出来的片段。

```
var parse_url = /^(?:([A-Za-z]+):)?(\/{0,3})([0-9.\-A-Za-z]+)(?::(\d+))?(?:\/([^?#]*))?(?:\?([^#]*))?(?:#(.*))?$/; 
var url = "http://www.ora.com:80/goodparts?q#fragment";
var result = parse_url.exec(url);
var names = ['url','scheme','slash','host','port','path','query','hash'];
var blanks = ' 		';
var i;

for(i=0;i<names.length;i++){
	document.writeln(names[i]+":"+
		blanks.substring(names[i].length),result[i]);
}
```

这段代码的结果如下：

```
 url:http://www.ora.com:80/goodparts?q#fragment 
 scheme:http 
 slash:// 
 host:www.ora.com
 port:80 
 path:goodparts 
 query:q 
 hash:fragment 

```

分解来看它的工作原理：

### ^

^字符表示字符串的开始，指引exec只匹配像URL一样的字符串。

### (?:([A-Za-z]+):)?

这个因子匹配一个协议名，并且只在后边跟随一个 : 的时候才可以匹配。

### (?:...)

表示一个非捕获型分组，后缀 ？ 表示这个分组是可选的，表示匹配 0 或 1 次， (...)表示一个捕获型分组

### (\/{0,3})

\/表示应该匹配 / (左斜杠)，用 \ (右斜杠)进行转义，后缀{0,3}表示 / 这个左斜杠需要匹配0，或者1-3次。

### ([0-9.\-A-Za-z]+)

匹配一个主机名，由一个或多个数字、字幕，及 . 或 - 组成， - 会被转义为 \- 以防止与表示范围的连字符相混淆。

### (?::(\d+))?

这是一个可选的因子匹配端口号，由一个前置的 : 加上一个或多个数字组成， \d 表示一个数字字符，一个或多个数字组成的字符串会被捕获型分组4捕获。

### (?:\/([^?#]*))?

这也是一个可选型的分组，以一个 / 开始，之后的字符类 [^?#]以一个^开始，表示这个类包含除 ? 和 # 之外的所有字符， * 表示匹配0或多次。

这里并不是一个严谨的写法，大多数正常的URL可以通过匹配，但是有一些包含恶意代码的文本也会通过，实际上并不能允许恶意代码。

### (?:\?([^#]*))?

一个以 ? 开始的可选分组，包含捕获型分组6，这个分组包含0个或多个非 # 字符。

### (?:#(.*))?

最后一个分组以 # 开始， . 会匹配除行结束符以外的所有字符。

### $
表示字符串结束，保证这个URL的尾部没有其他内容。




